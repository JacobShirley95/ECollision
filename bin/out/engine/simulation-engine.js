// Generated by CoffeeScript 1.10.0
(function() {
  var PVector, Particle, SimulationEngine;

  Particle = require('../objects/particle');

  PVector = require('../math/pvector');

  module.exports = SimulationEngine = (function() {
    var Collision, splitVelocity;

    SimulationEngine.prototype.particles = [];

    function SimulationEngine(width, height, settings) {
      this.width = width;
      this.height = height;
      this.settings = settings;
    }

    SimulationEngine.prototype.setBounds = function(width, height) {
      this.width = width;
      this.height = height;
    };

    SimulationEngine.prototype.reset = function() {
      return this.particles = [];
    };

    Collision = (function() {
      function Collision() {}

      Collision.prototype.time = 0.0;

      Collision.prototype.particle = null;

      Collision.prototype.particle2 = null;

      return Collision;

    })();

    SimulationEngine.prototype.edgeCollision = function(particle, rebound) {
      var cOR;
      cOR = particle.cOR;
      if (particle.x + particle.radius >= this.width) {
        if (rebound) {
          particle.xVel *= -cOR;
          particle.yVel *= cOR;
        } else {
          particle.x = this.width - particle.radius;
        }
      } else if (particle.x - particle.radius <= 0) {
        if (rebound) {
          particle.xVel *= -cOR;
          particle.yVel *= cOR;
        } else {
          particle.x = particle.radius;
        }
      }
      if (particle.y + particle.radius >= this.height) {
        if (rebound) {
          particle.xVel *= cOR;
          return particle.yVel *= -cOR;
        } else {
          return particle.y = this.height - particle.radius;
        }
      } else if (particle.y - particle.radius <= 0) {
        if (rebound) {
          particle.xVel *= cOR;
          return particle.yVel *= -cOR;
        } else {
          return particle.y = particle.radius;
        }
      }
    };

    SimulationEngine.prototype.collide = function(particle, particle2, collision) {
      var a, b, c, dX, dY, discr, pDiff, r, sqr, t, t2, vDiff;
      dX = particle2.x - particle.x;
      dY = particle2.y - particle.y;
      sqr = (dX * dX) + (dY * dY);
      r = particle2.radius + particle.radius;
      if (sqr < r * r) {
        pDiff = new PVector(particle.x - particle2.x, particle.y - particle2.y);
        vDiff = new PVector(particle.xVel - particle2.xVel, particle.yVel - particle2.yVel);
        a = vDiff.dotProduct(vDiff);
        b = -2 * vDiff.dotProduct(pDiff);
        c = (pDiff.dotProduct(pDiff)) - (r * r);
        discr = (b * b) - (4 * a * c);
        t = 0.0;
        t2 = 0.0;
        if (discr >= 0) {
          t = (-b - Math.sqrt(discr)) / (2 * a);
          t2 = (-b + Math.sqrt(discr)) / (2 * a);
        }
        if (t > 0.0 && t <= 1.0) {
          collision.time = t;
        } else if (t2 > 0.0 && t2 <= 1.0) {
          collision.time = t2;
        } else {
          collision.time = 1.0;
        }
        return true;
      }
      return false;
    };

    splitVelocity = function(particle1, particle2) {
      var a, ang, dx, dy, magnitude, velocity;
      velocity = new PVector(particle1.xVel, particle1.yVel);
      a = Math.PI / 2;
      if (particle1.xVel !== 0) {
        a = Math.atan(particle1.yVel / particle1.xVel);
      }
      magnitude = (particle1.xVel * Math.cos(-a) - particle1.yVel * Math.sin(-a)) * particle1.cOR;
      dx = particle1.x - particle2.x;
      dy = particle1.y - particle2.y;
      ang = 0;
      if (dx !== 0) {
        ang = Math.atan(dy / dx);
      } else {
        ang = Math.atan(dy / (dx - 0.00001));
      }
      velocity.x = magnitude * (Math.cos(ang - a));
      velocity.y = magnitude * (Math.sin(ang - a));
      return velocity;
    };

    SimulationEngine.prototype.handleCollision = function(collision) {
      var ang, cosA, newV, newV2, particle, particle2, particleVel, sinA, thisVel, x1, x2, y1, y2;
      particle = collision.particle;
      particle2 = collision.particle2;
      thisVel = splitVelocity(particle, particle2);
      particleVel = splitVelocity(particle2, particle);
      newV = ((thisVel.x * (particle.mass - particle2.mass)) + (2 * particle2.mass * particleVel.x)) / (particle.mass + particle2.mass);
      newV2 = ((particleVel.x * (particle2.mass - particle.mass)) + (2 * particle.mass * thisVel.x)) / (particle.mass + particle2.mass);
      ang = Math.atan((particle.y - particle2.y) / (particle.x - particle2.x));
      cosA = Math.cos(ang);
      sinA = Math.sin(ang);
      x1 = (newV * cosA) + (thisVel.y * sinA);
      y1 = (newV * sinA) - (thisVel.y * cosA);
      x2 = (newV2 * cosA) + (particleVel.y * sinA);
      y2 = (newV2 * sinA) - (particleVel.y * cosA);
      this.seperateObjects(collision, particle, particle2);
      particle.xVel = x1;
      particle.yVel = y1;
      particle2.xVel = x2;
      return particle2.yVel = y2;
    };

    SimulationEngine.prototype.seperateObjects = function(collision, particle, particle2) {
      var ang, dX, dY, i, overlap, sqr, t, vT, vel1, vel2;
      t = collision.time + (0.001 * collision.time);
      if (t < 1.0) {
        particle.x -= particle.xVel * this.settings.global.speedConst * t;
        particle.y -= particle.yVel * this.settings.global.speedConst * t;
        particle2.x -= particle2.xVel * this.settings.global.speedConst * t;
        return particle2.y -= particle2.yVel * this.settings.global.speedConst * t;
      } else {
        dX = particle2.x - particle.x;
        dY = particle2.y - particle.y;
        sqr = (dX * dX) + (dY * dY);
        overlap = particle2.radius - Math.abs(Math.sqrt(sqr) - particle.radius) + 0.1;
        vel1 = new PVector(particle.xVel, particle.yVel).getMagnitudeNS() + 0.0001;
        vel2 = new PVector(particle2.xVel, particle2.yVel).getMagnitudeNS() + 0.0001;
        vT = vel1 + vel2;
        i = vel1 / vT;
        ang = Math.atan2(particle.y - particle2.y, particle.x - particle2.x);
        particle.x += overlap * Math.cos(ang) * i;
        particle.y += overlap * Math.sin(ang) * i;
        i = 1 - i;
        particle2.x -= overlap * Math.cos(ang) * i;
        return particle2.y -= overlap * Math.sin(ang) * i;
      }
    };

    SimulationEngine.prototype.update = function() {
      var colObjects, collision, i, i2, j, k, l, len, len1, len2, len3, m, n, particle, particle2, ref, ref1, ref2, ref3, ref4, results;
      ref = this.particles;
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        this.edgeCollision(particle, true);
        particle.update();
      }
      colObjects = [];
      ref1 = this.particles;
      for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
        particle = ref1[i];
        for (i2 = l = ref2 = i + 1, ref3 = this.particles.length - 1; l <= ref3; i2 = l += 1) {
          particle2 = this.particles[i2];
          collision = new Collision();
          if (this.collide(particle, particle2, collision)) {
            collision.particle = particle;
            collision.particle2 = particle2;
            colObjects.push(collision);
          }
        }
      }
      colObjects.sort(function(a, b) {
        return a.time < b.time;
      });
      for (m = 0, len2 = colObjects.length; m < len2; m++) {
        collision = colObjects[m];
        this.handleCollision(collision);
      }
      ref4 = this.particles;
      results = [];
      for (n = 0, len3 = ref4.length; n < len3; n++) {
        particle = ref4[n];
        results.push(this.edgeCollision(particle, false));
      }
      return results;
    };

    return SimulationEngine;

  })();

}).call(this);
