// Generated by CoffeeScript 1.10.0
(function() {
  var ECollision, ECollisionSettings, EventManager, Graph, Overlay, Simulation, SimulationEngine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  SimulationEngine = require("./engine/simulation-engine");

  Simulation = require("./ui/simulation");

  Graph = require("./ui/graph");

  Overlay = require("./ui/overlay");

  ECollisionSettings = require("./settings");

  EventManager = require("./events/event-manager");

  module.exports = ECollision = (function() {
    var curTime, fps, fpsCount, fpsTime, interpolation, newTime, refreshTime, setSpeedConst, setUpdateRate, thread, timeStamp, updateRate, updateTime, widgets;

    widgets = [];

    fpsCount = fps = fpsTime = newTime = timeStamp = curTime = 0;

    interpolation = 0.0;

    thread = -1;

    updateRate = updateTime = refreshTime = 0;

    function ECollision(settings) {
      this.settings = settings;
      this.tick = bind(this.tick, this);
      this.engine = new SimulationEngine(this.settings.simulation.simulationWidth, this.settings.simulation.simulationHeight, this.settings);
      this.simulationUI = new Simulation(this.settings.simulation.simulationCanvas, this.engine, this.settings);
      this.graphUI = new Graph(this.settings.graph.graphCanvas, this.engine, 1 / 50, 5, this.settings);
      this.overlayUI = new Overlay(this.settings.overlay.overlayCanvas, this.simulationUI, this.settings);
      this.paused = false;
      this.fps = 0;
      widgets = [this.simulationUI, this.graphUI, this.overlayUI];
      updateRate = this.settings.global.updateRate;
      updateTime = 1000.0 / updateRate;
      refreshTime = 1000 / this.settings.global.refreshRate;
      EventManager.eventify(this);
    }

    ECollision.prototype.start = function() {
      var i, len, widget;
      for (i = 0, len = widgets.length; i < len; i++) {
        widget = widgets[i];
        widget.init();
      }
      return thread = setInterval(this.tick, 1000.0 / this.settings.global.refreshRate);
    };

    ECollision.prototype.restart = function() {
      var i, len, results, widget;
      results = [];
      for (i = 0, len = widgets.length; i < len; i++) {
        widget = widgets[i];
        results.push(widget.restart());
      }
      return results;
    };

    ECollision.prototype.resume = function() {
      var i, len, results, widget;
      this.paused = false;
      results = [];
      for (i = 0, len = widgets.length; i < len; i++) {
        widget = widgets[i];
        results.push(widget.resume());
      }
      return results;
    };

    ECollision.prototype.pause = function() {
      var i, len, results, widget;
      this.paused = true;
      results = [];
      for (i = 0, len = widgets.length; i < len; i++) {
        widget = widgets[i];
        results.push(widget.pause());
      }
      return results;
    };

    ECollision.prototype.stop = function() {
      if (thread !== -1) {
        clearInterval(thread);
        return thread = -1;
      }
    };

    ECollision.prototype.getUpdateRate = function() {
      return updateRate;
    };

    ECollision.prototype.getUpdateTime = function() {
      return updateTime;
    };

    setUpdateRate = function(rate) {
      updateRate = rate;
      return updateTime = 1000.0 / updateRate;
    };

    setSpeedConst = function(speedConst) {
      return this.engine.speedConst = speedConst;
    };

    ECollision.prototype.update = function() {
      var i, len, particle, ref;
      curTime += refreshTime;
      if (newTime + updateTime < curTime) {
        timeStamp = curTime;
        if (this.settings.global.enableInterpolation) {
          ref = this.engine.particles;
          for (i = 0, len = ref.length; i < len; i++) {
            particle = ref[i];
            particle.capture();
          }
        }
        while (newTime + updateTime < curTime) {
          this.engine.update();
          newTime += updateTime;
        }
      }
      return interpolation = Math.min(1.0, (curTime - timeStamp) / updateTime);
    };

    ECollision.prototype.tick = function() {
      var fpsCurTime, i, len, widget;
      if (!this.paused) {
        this.update();
      }
      fpsCurTime = new Date().getTime();
      fpsCount++;
      if (fpsCurTime - fpsTime >= 1000) {
        this.fps = fpsCount;
        fpsCount = 0;
        fpsTime = fpsCurTime;
      }
      for (i = 0, len = widgets.length; i < len; i++) {
        widget = widgets[i];
        widget.draw(interpolation);
      }
      return this.fire('tick', [interpolation]);
    };

    return ECollision;

  })();

}).call(this);
