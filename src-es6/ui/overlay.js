// Generated by CoffeeScript 2.2.2
var Overlay, gcd,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import Widget from "./widget.js";

import Particle from "../objects/particle.js";

import EaselJSRenderer from "./renderer/easeljs/easeljs-renderer.js";

gcd = function(a, b) {
  if (!b) {
    return a;
  }
  return gcd(b, a % b);
};

export default Overlay = (function() {
  class Overlay extends Widget {
    constructor(canvasName, simulation, interpol, settings) {
      super(canvasName);
      this.handleMouseWheel = this.handleMouseWheel.bind(this);
      this.handleMouseMove = this.handleMouseMove.bind(this);
      this.handleClick = this.handleClick.bind(this);
      this.simulation = simulation;
      this.interpol = interpol;
      this.settings = settings;
      this.modeText = new createjs.Text("", "bold 15px Arial");
      this.modeText.x = 0;
      this.modeText.y = 10;
      this.velocityLine = new createjs.Shape();
      this.velText = new createjs.Text("", "bold 15px Arial");
      this.velText.cache();
      this.errorText = new createjs.Text("", "bold 15px Arial", "red");
      this.mouseX = this.crossX = this.width / 2;
      this.mouseY = this.crossY = this.height / 2;
      this.mode = -1;
      this.index = 0;
      this.modeText.x = (this.width / 2) - 40;
      this.interval = gcd(this.width, this.height);
      this.hide();
      $(document).keydown((event) => {
        this.freePlace = event.ctrlKey;
        return this.copyPlace = event.shiftKey;
      });
      $(document).keyup((event) => {
        this.freePlace = false;
        return this.copyPlace = false;
      });
      this.canvas.bind('contextmenu', function(e) {
        return false;
      });
      this.mouseX = this.crossX = this.width / 2;
      this.mouseY = this.crossY = this.height / 2;
      this.stage.addEventListener("stagemousemove", this.handleMouseMove);
      this.canvas.mousedown(this.handleClick);
      this.canvas.mousewheel(this.handleMouseWheel);
      this.renderer = new EaselJSRenderer(this.stage, this.interpol, this.settings);
    }

    resize(width, height) {
      return this.interval = gcd(this.width, this.height);
    }

    init() {
      this.stage.removeAllChildren();
      this.renderer.removeParticle(this.tempObject);
      this.mouseX = this.crossX = this.width / 2;
      this.mouseY = this.crossY = this.height / 2;
      return this.stage.addChild(this.modeText);
    }

    handleMouseWheel(ev) {
      var d;
      boundMethodCheck(this, Overlay);
      d = ev.deltaY;
      if (d < 0) {
        if (this.tempObject.radius > this.settings.global.minRadius) {
          this.tempObject.radius -= 1;
        }
      } else {
        if (this.tempObject.radius < this.settings.global.maxRadius) {
          this.tempObject.radius += 1;
        }
      }
      return this.tempObject.needsUpdate = true;
    }

    handleMouseMove(ev) {
      var dx, dy, g, gridX, gridY, h, minX, minY, w;
      boundMethodCheck(this, Overlay);
      this.mouseX = this.crossX = ev.stageX;
      this.mouseY = this.crossY = ev.stageY;
      if (!this.freePlace) {
        gridX = Math.round(this.mouseX / this.interval);
        gridY = Math.round(this.mouseY / this.interval);
        this.crossX = gridX * this.interval;
        this.crossY = gridY * this.interval;
      }
      switch (this.index) {
        case Overlay.INDEX_PLACE:
          this.velocityLine.x = this.crossX;
          this.velocityLine.y = this.crossY;
          if (this.tempObject !== null) {
            this.tempObject.x = this.crossX;
            this.tempObject.y = this.crossY;
          }
          this.velText.x = this.crossX;
          this.velText.y = this.crossY;
          break;
        case Overlay.INDEX_VELOCITY:
          g = this.velocityLine.graphics;
          dx = this.crossX - this.velocityLine.x;
          dy = this.crossY - this.velocityLine.y;
          this.velText.x = this.velocityLine.x + (dx / 2);
          this.velText.y = this.velocityLine.y + (dy / 2);
          this.velText.text = Math.round(Math.sqrt(dx * dx + dy * dy)) + " px/s";
          this.velText.cache(0, 0, 100, 100);
          this.tempObject.xVel = dx / this.settings.global.updateRate;
          this.tempObject.yVel = dy / this.settings.global.updateRate;
          g.clear().beginStroke("red").setStrokeStyle(3).moveTo(0, 0).lineTo(dx, dy);
          minX = Math.min(dx, 0);
          minY = Math.min(dy, 0);
          w = Math.abs(dx);
          h = Math.abs(dy);
          this.velocityLine.cache(minX, minY, w, h);
          break;
      }
    }

    handleClick(ev) {
      var p, possibles, selected;
      boundMethodCheck(this, Overlay);
      if (ev.button === 2 && this.index !== Overlay.INDEX_MODIFY) {
        switch (this.index) {
          case Overlay.INDEX_PLACE:
            this.end();
            break;
          case Overlay.INDEX_VELOCITY:
            break;
        }
        this.reset();
      } else {
        switch (this.index) {
          case Overlay.INDEX_PLACE:
            this.velocityLine.graphics.clear();
            this.stage.addChild(this.velocityLine);
            this.stage.addChild(this.velText);
            this.index = Overlay.INDEX_VELOCITY;
            break;
          case Overlay.INDEX_VELOCITY:
            p = this.simulation.addParticle(this.tempObject.x, this.tempObject.y, this.tempObject.mass, this.tempObject.radius, this.tempObject.style);
            p.xVel = this.tempObject.xVel;
            p.yVel = this.tempObject.yVel;
            p.cOR = this.tempObject.cOR;
            this.stage.removeChild(this.velocityLine);
            this.stage.removeChild(this.velText);
            this.tempObject.xVel = this.tempObject.yVel = 0;
            if (this.mode === Overlay.MODE_EDIT && !this.copyPlace) {
              this.index = Overlay.INDEX_MODIFY;
              this.renderer.removeParticle(this.tempObject);
            } else {
              this.index = Overlay.INDEX_PLACE;
            }
            break;
          case Overlay.INDEX_MODIFY:
            possibles = this.simulation.renderer.getParticlesAtPos(this.mouseX, this.mouseY);
            if (possibles.length > 0) {
              selected = possibles[0].particle;
              this.simulation.removeParticle(selected);
              if (ev.button !== 2) {
                this.tempObject = selected.copy();
                this.particleRenderer = this.renderer.addParticle(this.tempObject);
                if (!this.copyPlace) {
                  this.simulation.removeSelected();
                }
                this.index = Overlay.INDEX_PLACE;
              }
            }
            break;
        }
      }
      return ev.stopPropagation();
    }

    draw(interpolation) {
      var i, len, p, ref;
      if (!this.hidden) {
        if (this.index === Overlay.INDEX_MODIFY) {
          ref = this.simulation.renderer.getParticles();
          for (i = 0, len = ref.length; i < len; i++) {
            p = ref[i];
            if (this.simulation.renderer.isParticleAtPos(p, this.mouseX, this.mouseY)) {
              p.select();
            } else {
              p.deselect();
            }
          }
        }
        if (this.showError) {
          this.errorTimer -= 1000 / this.settings.global.updateRate;
          if (this.errorTimer <= 0) {
            this.showError = false;
            this.stage.removeChild(this.errorText);
          }
        }
        return this.renderer.draw(interpolation);
      }
    }

    reset() {
      this.stage.removeChild(this.velocityLine);
      this.stage.removeChild(this.velText);
      return this.index = Overlay.INDEX_PLACE;
    }

    beginAdd(mass, cOR, style) {
      this.show();
      this.init();
      this.tempObject = new Particle(this.crossX, this.crossY, 25, style, this.settings);
      this.tempObject.mass = mass;
      this.tempObject.cOR = cOR;
      this.particleRenderer = this.renderer.addParticle(this.tempObject);
      this.particleRenderer.enableSelection = false;
      //@stage.addChild(@particleRenderer.displayObj);
      this.velText.x = this.mouseX;
      this.velText.y = this.mouseY;
      this.modeText.text = "Mode: Add";
      this.modeText.cache(0, 0, 100, 20);
      this.index = Overlay.INDEX_PLACE;
      return this.mode = Overlay.MODE_ADD;
    }

    beginEdit() {
      this.show();
      this.init();
      this.modeText.text = "Mode: Edit";
      this.index = Overlay.INDEX_MODIFY;
      return this.mode = Overlay.MODE_EDIT;
    }

    end() {
      this.hide();
      this.renderer.removeParticle(this.tempObject);
      this.tempObject = null;
      this.mode = -1;
      this.freePlace = false;
      return this.copyPlace = false;
    }

    getCurrentParticle() {
      return this.tempObject;
    }

    getMode() {
      return this.mode;
    }

  };

  Overlay.INDEX_PLACE = 0;

  Overlay.INDEX_VELOCITY = 1;

  Overlay.INDEX_MODIFY = 2;

  Overlay.MODE_ADD = 0;

  Overlay.MODE_EDIT = 1;

  Overlay.prototype.errorTimer = 0;

  Overlay.prototype.showError = false;

  Overlay.prototype.tempObject = null;

  return Overlay;

}).call(this);
