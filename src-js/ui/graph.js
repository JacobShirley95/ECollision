// Generated by CoffeeScript 1.10.0
(function() {
  var Graph, Particle, Point2D, Widget,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Widget = require("./widget");

  Particle = require('../objects/particle');

  Point2D = require('../math/point-2d');

  module.exports = Graph = (function(superClass) {
    extend(Graph, superClass);

    Graph.prototype.x = 0;

    Graph.prototype.y = 0;

    Graph.prototype.scaleX = 0;

    Graph.prototype.scaleY = 0;

    Graph.prototype.graph = new createjs.Shape();

    Graph.prototype.offsetX = 0.0;

    Graph.prototype.offsetY = 0.0;

    Graph.prototype.userY = 0;

    Graph.prototype.data = [];

    Graph.prototype.start = 0;

    Graph.prototype.maxLen = 150;

    Graph.prototype.updated = false;

    Graph.prototype.currX = 0;

    Graph.prototype.currY = 0;

    Graph.prototype.zoomIndex = 0;

    function Graph(canvasName, engine, scaleX, scaleY, settings) {
      this.engine = engine;
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.settings = settings;
      Graph.__super__.constructor.call(this, canvasName);
    }

    Graph.prototype.init = function() {
      var xAxis, yAxis;
      xAxis = new createjs.Shape();
      yAxis = new createjs.Shape();
      xAxis.graphics.beginStroke("red").moveTo(this.x, this.height).lineTo(this.width, this.height);
      yAxis.graphics.beginStroke("red").moveTo(this.x, this.y).lineTo(this.x, this.height);
      this.stage.addChild(xAxis);
      this.stage.addChild(yAxis);
      this.stage.addChild(this.graph);
      this.stage.update();
      return this.updateData();
    };

    Graph.prototype.draw = function(interpolation) {
      var g, i, i2, j, length, targetY, total, x1, x2, x3, y1, y2, y3;
      if (this.engine !== null) {
        g = this.graph.graphics;
        g.clear();
        length = this.data.length - 1;
        total = 0;
        j = 0;
        while (j < length - 1) {
          if (this.updated) {
            this.updated = false;
            return;
          }
          total += this.data[j].y;
          i = (this.start + j) % length;
          i2 = (this.start + j + 1) % length;
          x2 = (this.data[i].x * this.scaleX) - this.offsetX;
          y2 = (this.data[i].y * this.scaleY) + this.offsetY + this.userY;
          if (x2 > this.width) {
            this.offsetX += x2 - this.width;
          }
          x1 = (this.data[i].x * this.scaleX) - this.offsetX;
          y1 = (this.data[i].y * this.scaleY) + this.offsetY + this.userY;
          x3 = (this.data[i2].x * this.scaleX) - this.offsetX;
          y3 = (this.data[i2].y * this.scaleY) + this.offsetY + this.userY;
          g.beginStroke("red").moveTo(this.x + x1, this.y + this.height - y1).lineTo(this.x + x3, this.y + this.height - y3);
          j++;
        }
        if (!this.paused) {
          this.currX += 1000 / this.settings.global.updateRate;
          this.currY = this.getEnergy();
          this.addData(this.currX, this.currY);
        }
        this.dataY = total / this.data.length;
        targetY = this.height / 2;
        this.offsetY = targetY - (this.dataY * this.scaleY);
        return this.stage.update();
      }
    };

    Graph.prototype.restart = function() {
      this.data = [];
      this.start = 0;
      this.currX = this.currY = 0;
      this.offsetX = this.offsetY = 0;
      return this.updated = true;
    };

    Graph.prototype.calibrate = function() {
      return this.userY = 0;
    };

    Graph.prototype.zoomIn = function() {
      if (this.zoomIndex < this.settings.graph.graphMaxZoomIndex) {
        this.scaleX *= this.settings.graph.graphZoomFactor;
        this.scaleY *= this.settings.graph.graphZoomFactor;
        this.offsetX *= this.scaleX;
        this.offsetY *= this.scaleY;
        this.updateData();
        return this.zoomIndex++;
      } else {
        throw "ERROR: Maximum zoom reached";
      }
    };

    Graph.prototype.zoomOut = function() {
      if (this.zoomIndex > -this.settings.graph.graphMinZoomIndex) {
        this.scaleX /= this.settings.graph.graphZoomFactor;
        this.scaleY /= this.settings.graph.graphZoomFactor;
        this.offsetX *= this.scaleX;
        this.offsetY *= this.scaleY;
        this.updateData();
        return this.zoomIndex--;
      } else {
        throw "ERROR: Minimum zoom reached";
      }
    };

    Graph.prototype.moveUp = function() {
      return this.userY -= 5;
    };

    Graph.prototype.moveDown = function() {
      return this.userY += 5;
    };

    Graph.prototype.getZoomIndex = function() {
      return this.zoomIndex;
    };

    Graph.prototype.addData = function(x, y) {
      var s;
      if (this.data.length > this.maxLen) {
        s = this.start;
        this.start = (this.start + 1) % this.maxLen;
        return this.data[s] = new Point2D(x, y);
      } else {
        return this.data.push(new Point2D(x, y));
      }
    };

    Graph.prototype.updateData = function() {
      var aLen, diff, i, j, k, ref, ref1;
      this.data2 = [];
      this.maxLen = Math.round(this.width / ((1000 / this.settings.global.updateRate) * this.scaleX)) + 5;
      aLen = this.data.length - 1;
      diff = 0;
      if (aLen > this.maxLen) {
        diff = aLen - this.maxLen;
      }
      for (j = k = ref = diff, ref1 = aLen - 1; k <= ref1; j = k += 1) {
        i = (this.start + j) % aLen;
        this.data2.push(this.data[i]);
      }
      this.updated = true;
      this.start = 0;
      return this.data = this.data2;
    };

    Graph.prototype.getEnergy = function() {
      var energy, k, len, particle, ref;
      energy = 0.0;
      ref = this.engine.particles;
      for (k = 0, len = ref.length; k < len; k++) {
        particle = ref[k];
        energy += particle.getEnergy();
      }
      return Math.round(energy / 1000);
    };

    return Graph;

  })(Widget);

}).call(this);
