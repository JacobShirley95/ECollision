(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ecollision = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simulationEngine = require("./engine/simulation-engine.js");

var _simulationEngine2 = _interopRequireDefault(_simulationEngine);

var _simulation = require("./ui/simulation.js");

var _simulation2 = _interopRequireDefault(_simulation);

var _graph = require("./ui/graph.js");

var _graph2 = _interopRequireDefault(_graph);

var _overlay = require("./ui/overlay.js");

var _overlay2 = _interopRequireDefault(_overlay);

var _settings = require("./settings.js");

var _settings2 = _interopRequireDefault(_settings);

var _eventManager = require("./events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

var _interpolator = require("./interpolator.js");

var _interpolator2 = _interopRequireDefault(_interpolator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var ECollision;

exports.default = ECollision = function () {
  var setSpeedConst, setUpdateRate;

  var ECollision = function () {
    function ECollision(settings) {
      var _this = this;

      _classCallCheck(this, ECollision);

      this.tick = this.tick.bind(this);
      this.settings = settings;
      this.engine = new _simulationEngine2.default(this.settings.simulation.simulationWidth, this.settings.simulation.simulationHeight, this.settings);
      this.interpol = new _interpolator2.default(this.settings.global.refreshRate, this.settings.global.updateRate);
      this.interpol.lockFPS = true;
      this.widgets = [];
      if (this.settings.simulation.simulationCanvas) {
        this.simulationUI = new _simulation2.default(this.settings.simulation.simulationCanvas, this.engine, this.interpol, this.settings);
        this.widgets.push(this.simulationUI);
      }
      if (this.settings.graph) {
        this.graphUI = new _graph2.default(this.settings.graph.graphCanvas, this.engine, 1 / 50, 5, this.settings);
        this.widgets.push(this.graphUI);
      }
      if (this.settings.overlay) {
        this.overlayUI = new _overlay2.default(this.settings.overlay.overlayCanvas, this.simulationUI, this.interpol, this.settings);
        this.widgets.push(this.overlayUI);
      }
      this.paused = false;
      this.fpsCount = this.fps = this.fpsTime = 0;
      this.updateRate = this.updateTime = this.refreshTime = 0;
      this.interpol.addListener("update", function () {
        if (!_this.paused) {
          return _this.update();
        }
      }).addListener("render", this.tick);
      this.updateRate = this.settings.global.updateRate;
      this.updateTime = 1000.0 / this.updateRate;
      this.refreshTime = 1000 / this.settings.global.refreshRate;
      _eventManager2.default.eventify(this);
    }

    _createClass(ECollision, [{
      key: "start",
      value: function start() {
        var i, len, ref, widget;
        ref = this.widgets;
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          widget.init();
        }
        return this.interpol.start();
      }
    }, {
      key: "restart",
      value: function restart() {
        var i, len, ref, results, widget;
        ref = this.widgets;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          results.push(widget.restart());
        }
        return results;
      }
    }, {
      key: "resume",
      value: function resume() {
        var i, len, ref, results, widget;
        this.paused = false;
        ref = this.widgets;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          results.push(widget.resume());
        }
        return results;
      }
    }, {
      key: "pause",
      value: function pause() {
        var i, len, ref, results, widget;
        this.paused = true;
        ref = this.widgets;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          results.push(widget.pause());
        }
        return results;
      }
    }, {
      key: "stop",
      value: function stop() {
        return this.interpol.stop();
      }
    }, {
      key: "getUpdateRate",
      value: function getUpdateRate() {
        return this.updateRate;
      }
    }, {
      key: "getUpdateTime",
      value: function getUpdateTime() {
        return this.updateTime;
      }
    }, {
      key: "resize",
      value: function resize() {
        var i, len, ref, results, widget;
        ref = this.widgets;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          results.push(widget.resize());
        }
        return results;
      }
    }, {
      key: "update",
      value: function update() {
        return this.engine.update();
      }
    }, {
      key: "tick",
      value: function tick(interpolation) {
        var i, len, ref, widget;
        this.fpsCurTime = Date.now();
        this.fpsCount++;
        if (this.fpsCurTime - this.fpsTime >= 1000) {
          this.fps = this.fpsCount;
          this.fpsCount = 0;
          this.fpsTime = this.fpsCurTime;
        }
        ref = this.widgets;
        for (i = 0, len = ref.length; i < len; i++) {
          widget = ref[i];
          widget.draw(interpolation);
        }
        return this.fire('tick', [interpolation]);
      }
    }]);

    return ECollision;
  }();

  ;

  setUpdateRate = function setUpdateRate(rate) {
    this.updateRate = rate;
    return this.updateTime = 1000.0 / this.updateRate;
  };

  setSpeedConst = function setSpeedConst(speedConst) {
    return this.engine.speedConst = speedConst;
  };

  return ECollision;
}.call(undefined);

},{"./engine/simulation-engine.js":2,"./events/event-manager.js":3,"./interpolator.js":4,"./settings.js":9,"./ui/graph.js":11,"./ui/overlay.js":12,"./ui/simulation.js":17}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _particle = require("../objects/particle.js");

var _particle2 = _interopRequireDefault(_particle);

var _pvector = require("../math/pvector.js");

var _pvector2 = _interopRequireDefault(_pvector);

var _eventManager = require("../events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var SimulationEngine;

exports.default = SimulationEngine = function () {
  var Collision, splitVelocity;

  var SimulationEngine = function () {
    function SimulationEngine(width, height, settings) {
      _classCallCheck(this, SimulationEngine);

      this.width = width;
      this.height = height;
      this.settings = settings;
      _eventManager2.default.eventify(this);
    }

    _createClass(SimulationEngine, [{
      key: "setBounds",
      value: function setBounds(width, height) {
        this.width = width;
        this.height = height;
      }
    }, {
      key: "reset",
      value: function reset() {
        return this.particles = [];
      }

      //his detects if there is an edge collision.

    }, {
      key: "edgeCollision",
      value: function edgeCollision(particle, rebound) {
        var cOR;
        cOR = particle.cOR;
        //If the particle is outside the width set, it will be placed back inside
        if (particle.x + particle.radius >= this.width) {
          if (rebound) {
            //The particle may lose energy if it's coefficient of restitution is less than 1.
            particle.xVel *= -cOR;
            particle.yVel *= cOR;
          } else {
            particle.x = this.width - particle.radius;
          }
        } else if (particle.x - particle.radius <= 0) {
          if (rebound) {
            particle.xVel *= -cOR;
            particle.yVel *= cOR;
          } else {
            particle.x = particle.radius;
          }
        }
        //If the particle is outside the height set, it will be placed back inside
        if (particle.y + particle.radius >= this.height) {
          if (rebound) {
            particle.xVel *= cOR;
            return particle.yVel *= -cOR;
          } else {
            return particle.y = this.height - particle.radius;
          }
        } else if (particle.y - particle.radius <= 0) {
          if (rebound) {
            particle.xVel *= cOR;
            return particle.yVel *= -cOR;
          } else {
            return particle.y = particle.radius;
          }
        }
      }

      //This functions checks for a collision and returns true or false if yes. It also calculates the required amount of time to seperate the particles.

    }, {
      key: "collide",
      value: function collide(particle, particle2, collision) {
        var a, b, c, dX, dY, discr, pDiff, r, sqr, t, t2, vDiff;
        //Take the distances between the particles on the x and y axes
        dX = particle2.x - particle.x;
        dY = particle2.y - particle.y;
        //Calculate the square of the distance
        sqr = dX * dX + dY * dY;
        r = particle2.radius + particle.radius;
        this.fire("check-collision", [particle, particle2, sqr]);
        //Could sqrt to get the distance, but there's no need because the otherside would also have to be sqrted
        if (sqr < r * r) {
          //Now to get the time constant between the last update and this update at which the particles would have collided perfectly
          //Put into pvectors as we need to get the dot products
          pDiff = new _pvector2.default(particle.x - particle2.x, particle.y - particle2.y);
          vDiff = new _pvector2.default(particle.xVel - particle2.xVel, particle.yVel - particle2.yVel);
          //The following can be derived thus:
          //          At the time of a perfect collision:
          //              let dx = particle2_currentX - particle1_currentX
          //              let dy = particle2_currentY - particle1_currentY

          //              let diffVelocityX = particle2_velocityX-particle1_velocityX
          //              let diffVelocityY = particle2_velocityY-particle1_velocityY

          //              let particle1_xFinal = particle1_currentX - (particle1_velocityX * time)
          //              let particle1_yFinal = particle1_currentY - (particle1_velocityY * time)

          //              let particle2_xFinal = particle2_currentX - (particle2_velocityX * time)
          //              let particle2_yFinal = particle2_currentY - (particle2_velocityY * time)

          //          We need to solve for time:
          //              let diffX = particle2_xFinal-particle1_xFinal
          //              let diffY = particle2_yFinal-particle1_yFinal

          //          Rearranging and subbing-in this gives:
          //              diffX = particle2_currentX - (particle2_velocityX * time) - particle1_currentX - (particle1_velocityX * time)
          //                    = (particle2_currentX - particle1_currentX) - time*(particle2_velocityX-particle1_velocityX)
          //                    = dx - time*diffVelocityX

          //              diffY = particle2_currentY - (particle2_velocityY * time) - particle1_currentY - (particle1_velocityY * time)
          //                    = (particle2_currentY - particle1_currentY) - time*(particle2_velocityY-particle1_velocityY)
          //                    = dy - time*diffVelocityY

          //          Now it is just like a collision check, as above, except this time we can solve for time:
          //              let sqr = sqr(diffX) + sqr(diffY)
          //                      = sqr(dx - time*diffVelocityX) + sqr(dy - time*diffVelocityY)

          //          Now to expand the brackets:
          //              sqr = sqr(dx) - 2*time*diffVelocityX*dx + sqr(time)*sqr(diffVelocityX) + sqr(dy) - 2*time*diffVelocityY*dy + sqr(time)*sqr(diffVelocityY)

          //          We're trying to find time, and or a perfect collision, sqr must equal the sum of the radii squared
          //          So our quadratic equation is:
          //              let radiiSqred = sqr(particle1_radius+particle2_radius)

          //              sqr = a*sqr(time) + b*time + c-radiiSqred = 0
          //              a = sqr(diffVelocityX)+sqr(diffVelocityY) (NOTE: dotProduct as below)
          //              b = -2*(dx*diffVelocityX + diffVelocityY*dy) (NOTE: dotProduct as below)
          //              c = sqr(dx)+sqr(dy) - radiiSqred

          //          We then use the quadratic formula (-b +- sqrt(b*b - 4*a*c))/(2*a) to calculate time
          a = vDiff.dotProduct(vDiff);
          b = -2 * vDiff.dotProduct(pDiff);
          c = pDiff.dotProduct(pDiff) - r * r;
          discr = b * b - 4 * a * c;
          t = 0.0;
          t2 = 0.0;
          if (discr >= 0) {
            t = (-b - Math.sqrt(discr)) / (2 * a);
            t2 = (-b + Math.sqrt(discr)) / (2 * a);
          }
          if (t > 0.0 && t <= 1.0) {
            collision.time = t;
          } else if (t2 > 0.0 && t2 <= 1.0) {
            collision.time = t2;
          } else {
            collision.time = 1.0;
          }
          return true;
        }
        return false;
      }

      //This function actually handles the collision between two particles.

    }, {
      key: "handleCollision",
      value: function handleCollision(collision) {
        var ang, cosA, newV, newV2, particle, particle2, particleVel, sinA, thisVel, x1, x2, y1, y2;
        particle = collision.particle;
        particle2 = collision.particle2;
        //Split the velocities into parallel and perpendicular components. See "splitVelocity" above.
        thisVel = splitVelocity(particle, particle2);
        particleVel = splitVelocity(particle2, particle);
        //Finally do some real physics. This calculates the new velocities of the parallel components as if they were one-dimensional.
        newV = (thisVel.x * (particle.mass - particle2.mass) + 2 * particle2.mass * particleVel.x) / (particle.mass + particle2.mass);
        newV2 = (particleVel.x * (particle2.mass - particle.mass) + 2 * particle.mass * thisVel.x) / (particle.mass + particle2.mass);
        //Calculate the angle between the particles
        ang = Math.atan((particle.y - particle2.y) / (particle.x - particle2.x));
        cosA = Math.cos(ang);
        sinA = Math.sin(ang);
        //Then these new velocityies are split further so they fit the Cartesian coordinate system. They are then added to the remaining velocity from the perpendicular components
        x1 = newV * cosA + thisVel.y * sinA;
        y1 = newV * sinA - thisVel.y * cosA;
        x2 = newV2 * cosA + particleVel.y * sinA;
        y2 = newV2 * sinA - particleVel.y * cosA;
        //Seperate the particles. See "seperateObjects" below.
        this.seperateObjects(collision, particle, particle2);
        //Finally give each particle their new velocities.
        particle.xVel = x1;
        particle.yVel = y1;
        particle2.xVel = x2;
        return particle2.yVel = y2;
      }

      //This function seperates the particles after collision.

    }, {
      key: "seperateObjects",
      value: function seperateObjects(collision, particle, particle2) {
        var ang, dX, dY, i, overlap, sqr, t, vT, vel1, vel2;
        //Add a small extra amount of time so that the particles can never get stuck on each other
        t = collision.time + 0.001 * collision.time;
        if (t < 1.0) {
          //Pull both particles back by the perfect collision time. See "collide" function
          particle.x -= particle.xVel * this.settings.global.speedConst * t;
          particle.y -= particle.yVel * this.settings.global.speedConst * t;
          particle2.x -= particle2.xVel * this.settings.global.speedConst * t;
          return particle2.y -= particle2.yVel * this.settings.global.speedConst * t;
        } else {
          //Failsafe method of seperating particles

          //First calculate the overlap
          dX = particle2.x - particle.x;
          dY = particle2.y - particle.y;
          sqr = dX * dX + dY * dY;
          overlap = particle2.radius - Math.abs(Math.sqrt(sqr) - particle.radius) + 0.1;
          vel1 = new _pvector2.default(particle.xVel, particle.yVel).getMagnitudeNS() + 0.0001;
          vel2 = new _pvector2.default(particle2.xVel, particle2.yVel).getMagnitudeNS() + 0.0001;
          //Total velocity
          vT = vel1 + vel2;
          //Work out the first propotion for movement
          i = vel1 / vT;
          ang = Math.atan2(particle.y - particle2.y, particle.x - particle2.x);
          //Move particle
          particle.x += overlap * Math.cos(ang) * i;
          particle.y += overlap * Math.sin(ang) * i;
          //Work out other proportion for movement
          i = 1 - i;
          particle2.x -= overlap * Math.cos(ang) * i;
          return particle2.y -= overlap * Math.sin(ang) * i;
        }
      }

      //This function causes the particles to update and react to each other. It is the heart of the system.

    }, {
      key: "update",
      value: function update() {
        var colObjects, collision, i, i2, j, k, l, len, len1, len2, len3, m, n, particle, particle2, ref, ref1, ref2, ref3, ref4;
        ref = this.particles;
        //Loop through the particles, make sure they are not overlapping with the edges, then update their position.
        for (j = 0, len = ref.length; j < len; j++) {
          particle = ref[j];
          this.edgeCollision(particle, true);
          particle.update();
        }
        //Loop through the particles, check for collisions once between pairs of particles.
        //If colliding, add them to a collision array
        colObjects = [];
        ref1 = this.particles;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          particle = ref1[i];
          for (i2 = l = ref2 = i + 1, ref3 = this.particles.length - 1; 1 !== 0 && (1 > 0 ? l <= ref3 : l >= ref3); i2 = l += 1) {
            particle2 = this.particles[i2];
            collision = new Collision();
            if (this.collide(particle, particle2, collision)) {
              collision.particle = particle;
              collision.particle2 = particle2;
              colObjects.push(collision);
            }
          }
        }
        //Loop through the collision array and sort out which one happened first
        colObjects.sort(function (a, b) {
          return a.time < b.time;
        });
        //Handle the collisions stored in the collision array. See "handleCollision" above
        for (m = 0, len2 = colObjects.length; m < len2; m++) {
          collision = colObjects[m];
          this.handleCollision(collision);
        }
        ref4 = this.particles;
        //Finally check for an edge collision again but do not rebound the particle
        for (n = 0, len3 = ref4.length; n < len3; n++) {
          particle = ref4[n];
          this.edgeCollision(particle, false);
        }
        return this.fire("update");
      }
    }]);

    return SimulationEngine;
  }();

  ;

  SimulationEngine.prototype.particles = [];

  Collision = function () {
    //Collision class that stores which objects collided and a time constant of how much to seperate them by.
    var Collision = function Collision() {
      _classCallCheck(this, Collision);
    };

    ;

    Collision.prototype.time = 0.0;

    Collision.prototype.particle = null;

    Collision.prototype.particle2 = null;

    return Collision;
  }.call(this);

  //This function splits particle1's velocity into parallel and perpendicular components.
  splitVelocity = function splitVelocity(particle1, particle2) {
    var a, ang, dx, dy, magnitude, velocity;
    //The overall process of visualising how this works is:
    //      1. Imagine the collision happening such that particle1's velocity is rotated so that it is in one dimension, or the x-axis
    //      2. Then calculate its parallel and perpendicular components when it collides.
    //      3. Finally rotate these components back by the same amount.

    //Store the current velocity in a vector structure
    velocity = new _pvector2.default(particle1.xVel, particle1.yVel);
    //Default angle
    a = Math.PI / 2;
    //Calculate the angle of the velocity
    if (particle1.xVel !== 0) {
      a = Math.atan(particle1.yVel / particle1.xVel);
    }
    //Calculate the magnitude as if it were on the x-axis only. This was originally part of my rotate function.
    //See math/pector.js for similarities
    magnitude = (particle1.xVel * Math.cos(-a) - particle1.yVel * Math.sin(-a)) * particle1.cOR;
    dx = particle1.x - particle2.x;
    dy = particle1.y - particle2.y;
    //Calculate the position angle
    ang = 0;
    if (dx !== 0) {
      ang = Math.atan(dy / dx);
    } else {
      ang = Math.atan(dy / (dx - 0.00001));
    }
    //This is a simplification of multiple cosines and sines using trig identities. It is essentially doing stages 2 and 3 as stated above.
    velocity.x = magnitude * Math.cos(ang - a);
    velocity.y = magnitude * Math.sin(ang - a);
    return velocity;
  };

  return SimulationEngine;
}.call(undefined);

},{"../events/event-manager.js":3,"../math/pvector.js":6,"../objects/particle.js":7}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
/* EventManager, v1.0.1
*
* Copyright (c) 2009, Howard Rauscher
* Licensed under the MIT License
 */
var EventManager;

exports.default = EventManager = function () {
  var EventArg;

  //Based on the code https://gist.github.com/howardr/118668 - thanks!

  var EventManager = function () {
    function EventManager() {
      _classCallCheck(this, EventManager);

      this._listeners = [];
    }

    _createClass(EventManager, [{
      key: 'addListener',
      value: function addListener(name, fn) {
        (this._listeners[name] = this._listeners[name] || []).push(fn);
        return this;
      }
    }, {
      key: 'removeListener',
      value: function removeListener(name, fn) {
        var foundAt, i, j, len1, listener, listeners;
        if (arguments.length === 1) {
          this._listeners[name] = [];
        } else if (typeof fn === 'function') {
          listeners = this._listeners[name];
          if (listeners !== void 0) {
            foundAt = -1;
            for (i = j = 0, len1 = listeners.length; j < len1; i = ++j) {
              listener = listeners[i];
              if (listener === fn) {
                foundAt = i;
                break;
              }
            }
            if (foundAt >= 0) {
              listeners.splice(foundAt, 1);
            }
          }
        }
        return this;
      }
    }, {
      key: 'fire',
      value: function fire(name, args) {
        var data, evt, i, j, len, len1, listener, listeners;
        listeners = this._listeners[name];
        args = args || [];
        if (listeners !== void 0) {
          data = {};
          evt = null;
          for (i = j = 0, len1 = listeners.length; j < len1; i = ++j) {
            listener = listeners[i];
            evt = new EventArg(name, data);
            listener.apply(window, args.concat(evt));
            data = evt.data;
            if (evt.removed) {
              listeners.splice(i, 1);
              len = listeners.length;
              --i;
            }
            if (evt.cancelled) {
              break;
            }
          }
        }
        return this;
      }
    }, {
      key: 'hasListeners',
      value: function hasListeners(name) {
        var ref;
        return ((ref = this._listeners[name] === void 0) != null ? ref : {
          0: this._listeners[name].length
        }) > 0;
      }
    }], [{
      key: 'eventify',
      value: function eventify(object, manager) {
        var func, j, len1, method, methods, results;
        methods = ['addListener', 'removeListener', 'fire'];
        manager = manager || new EventManager();
        func = function func(method) {
          return object[method] = function () {
            return manager[method].apply(manager, arguments);
          };
        };
        results = [];
        for (j = 0, len1 = methods.length; j < len1; j++) {
          method = methods[j];
          results.push(func(method));
        }
        return results;
      }
    }]);

    return EventManager;
  }();

  ;

  EventArg = function () {
    function EventArg(name1, data1) {
      _classCallCheck(this, EventArg);

      this.name = name1;
      this.data = data1;
      this.cancelled = false;
      this.removed = false;
    }

    _createClass(EventArg, [{
      key: 'cancel',
      value: function cancel() {
        return this.cancelled = true;
      }
    }, {
      key: 'remove',
      value: function remove() {
        return this.removed = true;
      }
    }]);

    return EventArg;
  }();

  return EventManager;
}.call(undefined);

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventManager = require("./events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var Interpolator;

exports.default = Interpolator = function () {
  var Interpolator = function () {
    function Interpolator(renderRate, updateRate) {
      _classCallCheck(this, Interpolator);

      this._start = this._start.bind(this);
      this.update = this.update.bind(this);
      this.renderRate = renderRate;
      this.updateRate = updateRate;
      this.lastTime = Date.now();
      this.updateTime = 1000.0 / this.updateRate;
      this.renderTime = 1000.0 / this.renderRate;
      this.updateCatchup = this.updateTime;
      this.maxUpdateCatchup = this.updateTime * 3;
      this.started = false;
      _eventManager2.default.eventify(this);
    }

    _createClass(Interpolator, [{
      key: "start",
      value: function start() {
        this.started = true;
        return this._start();
      }
    }, {
      key: "_start",
      value: function _start() {
        if (this.started) {
          this.update();
          return requestAnimationFrame(this._start);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        return this.started = false;
      }
    }, {
      key: "setMaxUpdateCatchup",
      value: function setMaxUpdateCatchup(maxUpdateCatchup) {
        return this.maxUpdateCatchup = maxUpdateCatchup;
      }
    }, {
      key: "update",
      value: function update() {
        var delta, t;
        if (this.updateCatchup >= this.updateTime) {
          this.fire("before-update");
          t = 0;
          while (this.updateCatchup >= this.updateTime && t < 7) {
            this.fire("update");
            this.updateCatchup -= this.updateTime;
            t++;
          }
          this.fire("after-update");
        }
        delta = Date.now() - this.lastTime;
        this.updateCatchup += Math.min(delta, this.maxUpdateCatchup);
        this.lastTime += delta;
        this.interpolation = Math.min(1.0, delta / this.updateTime);
        return this.fire("render", [this.interpolation]);
      }
    }], [{
      key: "interpolate",
      value: function interpolate(startVal, endVal, fraction) {
        return startVal + fraction * (endVal - startVal);
      }
    }]);

    return Interpolator;
  }();

  ;

  Interpolator.prototype.interpolation = 0.0;

  Interpolator.prototype.lockFPS = false;

  return Interpolator;
}.call(undefined);

},{"./events/event-manager.js":3}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var Point2D;

exports.default = Point2D = function Point2D(x, y) {
  _classCallCheck(this, Point2D);

  this.x = x;
  this.y = y;
};

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var PVector;

exports.default = PVector = function () {
  function PVector(x, y) {
    _classCallCheck(this, PVector);

    this.x = x;
    this.y = y;
  }

  _createClass(PVector, [{
    key: "getMagnitude",
    value: function getMagnitude() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "getMagnitudeNS",
    value: function getMagnitudeNS() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(vec) {
      return this.x * vec.x + this.y * vec.y;
    }
  }, {
    key: "getNormal",
    value: function getNormal() {
      return new PVector(-this.y, this.x);
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      var x2, y2;
      x2 = this.x;
      y2 = this.y;
      this.x = x2 * Math.cos(angle) - y2 * Math.sin(angle);
      return this.y = x2 * Math.sin(angle) + y2 * Math.cos(angle);
    }
  }]);

  return PVector;
}();

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _physicsObject = require("./physics-object.js");

var _physicsObject2 = _interopRequireDefault(_physicsObject);

var _point2d = require("../math/point-2d.js");

var _point2d2 = _interopRequireDefault(_point2d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var Particle;

exports.default = Particle = function () {
  var Particle = function (_PhysicsObject) {
    _inherits(Particle, _PhysicsObject);

    function Particle(x, y, radius, style, settings) {
      _classCallCheck(this, Particle);

      var _this = _possibleConstructorReturn(this, (Particle.__proto__ || Object.getPrototypeOf(Particle)).call(this, x, y, 0));

      _this.radius = radius;
      _this.style = style;
      _this.settings = settings;
      _this.needsUpdate = false;
      return _this;
    }

    _createClass(Particle, [{
      key: "update",
      value: function update() {
        this.x += this.xVel * this.settings.global.speedConst;
        return this.y += this.yVel * this.settings.global.speedConst;
      }
    }, {
      key: "copy",
      value: function copy() {
        var p;
        p = new Particle(this.x, this.y, this.radius, this.style, this.settings);
        p.index = this.index;
        p.cOR = this.cOR;
        p.mass = this.mass;
        p.xVel = this.xVel;
        p.yVel = this.yVel;
        return p;
      }
    }]);

    return Particle;
  }(_physicsObject2.default);

  ;

  Particle.prototype.cOR = 1.0;

  Particle.prototype.renderer = null;

  return Particle;
}.call(undefined);

},{"../math/point-2d.js":5,"./physics-object.js":8}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventManager = require("../events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var PhysicsObject;

exports.default = PhysicsObject = function () {
  var PhysicsObject = function () {
    function PhysicsObject(x, y, mass) {
      _classCallCheck(this, PhysicsObject);

      this.x = x;
      this.y = y;
      this.mass = mass;
      this.lastX = this.x;
      this.lastY = this.y;
      _eventManager2.default.eventify(this);
    }

    _createClass(PhysicsObject, [{
      key: "capture",
      value: function capture() {
        this.lastX = this.x;
        return this.lastY = this.y;
      }
    }, {
      key: "update",
      value: function update() {
        this.x += this.xVel;
        return this.y += this.yVel;
      }
    }, {
      key: "getEnergy",
      value: function getEnergy() {
        return 0.5 * this.mass * (this.xVel * this.xVel + this.yVel * this.yVel);
      }
    }]);

    return PhysicsObject;
  }();

  ;

  PhysicsObject.prototype.xVel = 0;

  PhysicsObject.prototype.yVel = 0;

  return PhysicsObject;
}.call(undefined);

},{"../events/event-manager.js":3}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var ECollisionSettings;

exports.default = ECollisionSettings = function () {
  var ECollisionSettings = function ECollisionSettings() {
    _classCallCheck(this, ECollisionSettings);
  };

  ;

  ECollisionSettings.prototype.global = {
    refreshRate: 24,
    updateRate: 60,
    showVelocities: false,
    enableInterpolation: true,
    maxTraceLength: 30,
    speedConst: 1.0,
    maxParticles: 10000,
    minRadius: 5,
    maxRadius: 30,
    errorTime: 5000
  };

  ECollisionSettings.prototype.simulation = {
    simulationWidth: 1000,
    simulationHeight: 1000,
    simulationCanvas: "simulation-canvas",
    enableSelection: true
  };

  ECollisionSettings.prototype.graph = {
    graphCanvas: "graph-canvas",
    graphScaleX: 1 / 50,
    graphScaleY: 5,
    graphZoomFactor: 1.25,
    graphMinZoomIndex: 5,
    graphMaxZoomIndex: 5
  };

  ECollisionSettings.prototype.overlay = {
    overlayCanvas: "overlay-canvas"
  };

  return ECollisionSettings;
}.call(undefined);

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EaselJSRenderer = exports.SimulationRenderer = exports.SimulationEngine = exports.ECollisionSettings = exports.ECollision = undefined;

var _ecollision = require("./ecollision.js");

var _ecollision2 = _interopRequireDefault(_ecollision);

var _settings = require("./settings.js");

var _settings2 = _interopRequireDefault(_settings);

var _simulationEngine = require("./engine/simulation-engine.js");

var _simulationEngine2 = _interopRequireDefault(_simulationEngine);

var _simulationRenderer = require("./ui/renderer/simulation-renderer.js");

var _simulationRenderer2 = _interopRequireDefault(_simulationRenderer);

var _easeljsRenderer = require("./ui/renderer/easeljs/easeljs-renderer.js");

var _easeljsRenderer2 = _interopRequireDefault(_easeljsRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.ECollision = _ecollision2.default;
exports.ECollisionSettings = _settings2.default;
exports.SimulationEngine = _simulationEngine2.default;
exports.SimulationRenderer = _simulationRenderer2.default;
exports.EaselJSRenderer = _easeljsRenderer2.default; // Generated by CoffeeScript 2.2.2

},{"./ecollision.js":1,"./engine/simulation-engine.js":2,"./settings.js":9,"./ui/renderer/easeljs/easeljs-renderer.js":13,"./ui/renderer/simulation-renderer.js":16}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widget = require("./widget.js");

var _widget2 = _interopRequireDefault(_widget);

var _particle = require("../objects/particle.js");

var _particle2 = _interopRequireDefault(_particle);

var _point2d = require("../math/point-2d.js");

var _point2d2 = _interopRequireDefault(_point2d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var Graph;

exports.default = Graph = function () {
  var Graph = function (_Widget) {
    _inherits(Graph, _Widget);

    function Graph(canvasName, engine, scaleX, scaleY, settings) {
      _classCallCheck(this, Graph);

      var _this = _possibleConstructorReturn(this, (Graph.__proto__ || Object.getPrototypeOf(Graph)).call(this, canvasName));

      _this.engine = engine;
      _this.scaleX = scaleX;
      _this.scaleY = scaleY;
      _this.settings = settings;
      return _this;
    }

    _createClass(Graph, [{
      key: "init",
      value: function init() {
        var xAxis, yAxis;
        xAxis = new createjs.Shape();
        yAxis = new createjs.Shape();
        xAxis.graphics.beginStroke("red").moveTo(this.x, 0).lineTo(this.width, 0);
        xAxis.x = this.x;
        xAxis.y = this.height;
        yAxis.graphics.beginStroke("red").moveTo(0, this.y).lineTo(0, this.height);
        yAxis.x = this.x;
        yAxis.y = 0;
        xAxis.cache(-1, -5, this.width, 10);
        yAxis.cache(-5, -1, 10, this.height);
        this.stage.addChild(xAxis);
        this.stage.addChild(yAxis);
        this.stage.addChild(this.graph);
        this.stage.update();
        return this.updateData();
      }
    }, {
      key: "draw",
      value: function draw(interpolation) {
        var g, i, i2, j, length, targetY, total, x1, x2, x3, y1, y2, y3;
        if (this.engine !== null) {
          g = this.graph.graphics;
          g.clear();
          length = this.data.length - 1;
          total = 0;
          j = 0;
          while (j < length - 1) {
            if (this.updated) {
              this.updated = false;
              return;
            }
            total += this.data[j].y;
            //calculate offsetted index for point at index j
            i = (this.start + j) % length;
            i2 = (this.start + j + 1) % length;
            x2 = this.data[i].x * this.scaleX - this.offsetX;
            y2 = this.data[i].y * this.scaleY + this.offsetY + this.userY;
            //if second x value is larger than width, move graph along
            if (x2 > this.width) {
              this.offsetX += x2 - this.width;
            }
            x1 = this.data[i].x * this.scaleX - this.offsetX;
            y1 = this.data[i].y * this.scaleY + this.offsetY + this.userY;
            x3 = this.data[i2].x * this.scaleX - this.offsetX;
            y3 = this.data[i2].y * this.scaleY + this.offsetY + this.userY;
            g.beginStroke("red").moveTo(this.x + x1, this.y + this.height - y1).lineTo(this.x + x3, this.y + this.height - y3);
            j++;
          }
          if (!this.paused) {
            this.currX += 1000 / this.settings.global.updateRate;
            this.currY = this.getEnergy();
            this.addData(this.currX, this.currY);
          }
          this.graph.cache(0, 0, this.width, this.height);
          this.dataY = total / this.data.length;
          targetY = this.height / 2;
          this.offsetY = targetY - this.dataY * this.scaleY;
          return this.stage.update();
        }
      }
    }, {
      key: "restart",
      value: function restart() {
        this.data = [];
        this.start = 0;
        this.currX = this.currY = 0;
        this.offsetX = this.offsetY = 0;
        return this.updated = true;
      }
    }, {
      key: "calibrate",
      value: function calibrate() {
        return this.userY = 0;
      }
    }, {
      key: "zoomIn",
      value: function zoomIn() {
        if (this.zoomIndex < this.settings.graph.graphMaxZoomIndex) {
          this.scaleX *= this.settings.graph.graphZoomFactor;
          this.scaleY *= this.settings.graph.graphZoomFactor;
          this.offsetX *= this.scaleX;
          this.offsetY *= this.scaleY;
          this.updateData();
          return this.zoomIndex++;
        } else {
          throw "ERROR: Maximum zoom reached";
        }
      }
    }, {
      key: "zoomOut",
      value: function zoomOut() {
        if (this.zoomIndex > -this.settings.graph.graphMinZoomIndex) {
          this.scaleX /= this.settings.graph.graphZoomFactor;
          this.scaleY /= this.settings.graph.graphZoomFactor;
          this.offsetX *= this.scaleX;
          this.offsetY *= this.scaleY;
          this.updateData();
          return this.zoomIndex--;
        } else {
          throw "ERROR: Minimum zoom reached";
        }
      }
    }, {
      key: "moveUp",
      value: function moveUp() {
        return this.userY -= 5;
      }
    }, {
      key: "moveDown",
      value: function moveDown() {
        return this.userY += 5;
      }
    }, {
      key: "getZoomIndex",
      value: function getZoomIndex() {
        return this.zoomIndex;
      }
    }, {
      key: "addData",
      value: function addData(x, y) {
        var s;
        if (this.data.length > this.maxLen) {
          s = this.start;
          this.start = (this.start + 1) % this.maxLen;
          return this.data[s] = new _point2d2.default(x, y);
        } else {
          return this.data.push(new _point2d2.default(x, y));
        }
      }
    }, {
      key: "updateData",
      value: function updateData() {
        var aLen, diff, i, j, k, ref, ref1;
        this.data2 = [];
        this.maxLen = Math.round(this.width / (1000 / this.settings.global.updateRate * this.scaleX)) + 5;
        aLen = this.data.length - 1;
        diff = 0;
        if (aLen > this.maxLen) {
          diff = aLen - this.maxLen;
        }
        for (j = k = ref = diff, ref1 = aLen - 1; 1 !== 0 && (1 > 0 ? k <= ref1 : k >= ref1); j = k += 1) {
          i = (this.start + j) % aLen;
          this.data2.push(this.data[i]);
        }
        this.updated = true;
        this.start = 0;
        return this.data = this.data2;
      }
    }, {
      key: "getEnergy",
      value: function getEnergy() {
        var energy, k, len, particle, ref;
        energy = 0.0;
        ref = this.engine.particles;
        for (k = 0, len = ref.length; k < len; k++) {
          particle = ref[k];
          energy += particle.getEnergy();
        }
        return Math.round(energy / 1000);
      }
    }]);

    return Graph;
  }(_widget2.default);

  ;

  Graph.prototype.x = 0;

  Graph.prototype.y = 0;

  Graph.prototype.scaleX = 0;

  Graph.prototype.scaleY = 0;

  Graph.prototype.graph = new createjs.Shape();

  Graph.prototype.offsetX = 0.0;

  Graph.prototype.offsetY = 0.0;

  Graph.prototype.userY = 0;

  Graph.prototype.data = [];

  Graph.prototype.start = 0;

  Graph.prototype.maxLen = 150;

  Graph.prototype.updated = false;

  Graph.prototype.currX = 0;

  Graph.prototype.currY = 0;

  Graph.prototype.zoomIndex = 0;

  return Graph;
}.call(undefined);

},{"../math/point-2d.js":5,"../objects/particle.js":7,"./widget.js":18}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widget = require("./widget.js");

var _widget2 = _interopRequireDefault(_widget);

var _particle = require("../objects/particle.js");

var _particle2 = _interopRequireDefault(_particle);

var _easeljsRenderer = require("./renderer/easeljs/easeljs-renderer.js");

var _easeljsRenderer2 = _interopRequireDefault(_easeljsRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var Overlay,
    _gcd,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

_gcd = function gcd(a, b) {
  if (!b) {
    return a;
  }
  return _gcd(b, a % b);
};

exports.default = Overlay = function () {
  var Overlay = function (_Widget) {
    _inherits(Overlay, _Widget);

    function Overlay(canvasName, simulation, interpol, settings) {
      _classCallCheck(this, Overlay);

      var _this = _possibleConstructorReturn(this, (Overlay.__proto__ || Object.getPrototypeOf(Overlay)).call(this, canvasName));

      _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
      _this.handleMouseMove = _this.handleMouseMove.bind(_this);
      _this.handleClick = _this.handleClick.bind(_this);
      _this.simulation = simulation;
      _this.interpol = interpol;
      _this.settings = settings;
      _this.modeText = new createjs.Text("", "bold 15px Arial");
      _this.modeText.x = 0;
      _this.modeText.y = 10;
      _this.velocityLine = new createjs.Shape();
      _this.velText = new createjs.Text("", "bold 15px Arial");
      _this.velText.cache();
      _this.errorText = new createjs.Text("", "bold 15px Arial", "red");
      _this.mouseX = _this.crossX = _this.width / 2;
      _this.mouseY = _this.crossY = _this.height / 2;
      _this.mode = -1;
      _this.index = 0;
      _this.modeText.x = _this.width / 2 - 40;
      _this.interval = _gcd(_this.width, _this.height);
      _this.hide();
      $(document).keydown(function (event) {
        _this.freePlace = event.ctrlKey;
        return _this.copyPlace = event.shiftKey;
      });
      $(document).keyup(function (event) {
        _this.freePlace = false;
        return _this.copyPlace = false;
      });
      _this.canvas.bind('contextmenu', function (e) {
        return false;
      });
      _this.mouseX = _this.crossX = _this.width / 2;
      _this.mouseY = _this.crossY = _this.height / 2;
      _this.stage.addEventListener("stagemousemove", _this.handleMouseMove);
      _this.canvas.mousedown(_this.handleClick);
      _this.canvas.mousewheel(_this.handleMouseWheel);
      _this.renderer = new _easeljsRenderer2.default(_this.stage, _this.interpol, _this.settings);
      return _this;
    }

    _createClass(Overlay, [{
      key: "resize",
      value: function resize(width, height) {
        return this.interval = _gcd(this.width, this.height);
      }
    }, {
      key: "init",
      value: function init() {
        this.stage.removeAllChildren();
        this.renderer.removeParticle(this.tempObject);
        this.mouseX = this.crossX = this.width / 2;
        this.mouseY = this.crossY = this.height / 2;
        return this.stage.addChild(this.modeText);
      }
    }, {
      key: "handleMouseWheel",
      value: function handleMouseWheel(ev) {
        var d;
        boundMethodCheck(this, Overlay);
        d = ev.deltaY;
        if (d < 0) {
          if (this.tempObject.radius > this.settings.global.minRadius) {
            this.tempObject.radius -= 1;
          }
        } else {
          if (this.tempObject.radius < this.settings.global.maxRadius) {
            this.tempObject.radius += 1;
          }
        }
        return this.tempObject.needsUpdate = true;
      }
    }, {
      key: "handleMouseMove",
      value: function handleMouseMove(ev) {
        var dx, dy, g, gridX, gridY, h, minX, minY, w;
        boundMethodCheck(this, Overlay);
        this.mouseX = this.crossX = ev.stageX;
        this.mouseY = this.crossY = ev.stageY;
        if (!this.freePlace) {
          gridX = Math.round(this.mouseX / this.interval);
          gridY = Math.round(this.mouseY / this.interval);
          this.crossX = gridX * this.interval;
          this.crossY = gridY * this.interval;
        }
        switch (this.index) {
          case Overlay.INDEX_PLACE:
            this.velocityLine.x = this.crossX;
            this.velocityLine.y = this.crossY;
            if (this.tempObject !== null) {
              this.tempObject.x = this.crossX;
              this.tempObject.y = this.crossY;
            }
            this.velText.x = this.crossX;
            this.velText.y = this.crossY;
            break;
          case Overlay.INDEX_VELOCITY:
            g = this.velocityLine.graphics;
            dx = this.crossX - this.velocityLine.x;
            dy = this.crossY - this.velocityLine.y;
            this.velText.x = this.velocityLine.x + dx / 2;
            this.velText.y = this.velocityLine.y + dy / 2;
            this.velText.text = Math.round(Math.sqrt(dx * dx + dy * dy)) + " px/s";
            this.velText.cache(0, 0, 100, 100);
            this.tempObject.xVel = dx / this.settings.global.updateRate;
            this.tempObject.yVel = dy / this.settings.global.updateRate;
            g.clear().beginStroke("red").setStrokeStyle(3).moveTo(0, 0).lineTo(dx, dy);
            minX = Math.min(dx, 0);
            minY = Math.min(dy, 0);
            w = Math.abs(dx);
            h = Math.abs(dy);
            this.velocityLine.cache(minX, minY, w, h);
            break;
        }
      }
    }, {
      key: "handleClick",
      value: function handleClick(ev) {
        var p, possibles, selected;
        boundMethodCheck(this, Overlay);
        if (ev.button === 2 && this.index !== Overlay.INDEX_MODIFY) {
          switch (this.index) {
            case Overlay.INDEX_PLACE:
              this.end();
              break;
            case Overlay.INDEX_VELOCITY:
              break;
          }
          this.reset();
        } else {
          switch (this.index) {
            case Overlay.INDEX_PLACE:
              this.velocityLine.graphics.clear();
              this.stage.addChild(this.velocityLine);
              this.stage.addChild(this.velText);
              this.index = Overlay.INDEX_VELOCITY;
              break;
            case Overlay.INDEX_VELOCITY:
              p = this.simulation.addParticle(this.tempObject.x, this.tempObject.y, this.tempObject.mass, this.tempObject.radius, this.tempObject.style);
              p.xVel = this.tempObject.xVel;
              p.yVel = this.tempObject.yVel;
              p.cOR = this.tempObject.cOR;
              this.stage.removeChild(this.velocityLine);
              this.stage.removeChild(this.velText);
              this.tempObject.xVel = this.tempObject.yVel = 0;
              if (this.mode === Overlay.MODE_EDIT && !this.copyPlace) {
                this.index = Overlay.INDEX_MODIFY;
                this.renderer.removeParticle(this.tempObject);
              } else {
                this.index = Overlay.INDEX_PLACE;
              }
              break;
            case Overlay.INDEX_MODIFY:
              possibles = this.simulation.renderer.getParticlesAtPos(this.mouseX, this.mouseY);
              if (possibles.length > 0) {
                selected = possibles[0].particle;
                this.simulation.removeParticle(selected);
                if (ev.button !== 2) {
                  this.tempObject = selected.copy();
                  this.particleRenderer = this.renderer.addParticle(this.tempObject);
                  if (!this.copyPlace) {
                    this.simulation.removeSelected();
                  }
                  this.index = Overlay.INDEX_PLACE;
                }
              }
              break;
          }
        }
        return ev.stopPropagation();
      }
    }, {
      key: "draw",
      value: function draw(interpolation) {
        var i, len, p, ref;
        if (!this.hidden) {
          if (this.index === Overlay.INDEX_MODIFY) {
            ref = this.simulation.renderer.getParticles();
            for (i = 0, len = ref.length; i < len; i++) {
              p = ref[i];
              if (this.simulation.renderer.isParticleAtPos(p, this.mouseX, this.mouseY)) {
                p.select();
              } else {
                p.deselect();
              }
            }
          }
          if (this.showError) {
            this.errorTimer -= 1000 / this.settings.global.updateRate;
            if (this.errorTimer <= 0) {
              this.showError = false;
              this.stage.removeChild(this.errorText);
            }
          }
          return this.renderer.draw(interpolation);
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this.stage.removeChild(this.velocityLine);
        this.stage.removeChild(this.velText);
        return this.index = Overlay.INDEX_PLACE;
      }
    }, {
      key: "beginAdd",
      value: function beginAdd(mass, cOR, style) {
        this.show();
        this.init();
        this.tempObject = new _particle2.default(this.crossX, this.crossY, 25, style, this.settings);
        this.tempObject.mass = mass;
        this.tempObject.cOR = cOR;
        this.particleRenderer = this.renderer.addParticle(this.tempObject);
        this.particleRenderer.enableSelection = false;
        //@stage.addChild(@particleRenderer.displayObj);
        this.velText.x = this.mouseX;
        this.velText.y = this.mouseY;
        this.modeText.text = "Mode: Add";
        this.modeText.cache(0, 0, 100, 20);
        this.index = Overlay.INDEX_PLACE;
        return this.mode = Overlay.MODE_ADD;
      }
    }, {
      key: "beginEdit",
      value: function beginEdit() {
        this.show();
        this.init();
        this.modeText.text = "Mode: Edit";
        this.index = Overlay.INDEX_MODIFY;
        return this.mode = Overlay.MODE_EDIT;
      }
    }, {
      key: "end",
      value: function end() {
        this.hide();
        this.renderer.removeParticle(this.tempObject);
        this.tempObject = null;
        this.mode = -1;
        this.freePlace = false;
        return this.copyPlace = false;
      }
    }, {
      key: "getCurrentParticle",
      value: function getCurrentParticle() {
        return this.tempObject;
      }
    }, {
      key: "getMode",
      value: function getMode() {
        return this.mode;
      }
    }]);

    return Overlay;
  }(_widget2.default);

  ;

  Overlay.INDEX_PLACE = 0;

  Overlay.INDEX_VELOCITY = 1;

  Overlay.INDEX_MODIFY = 2;

  Overlay.MODE_ADD = 0;

  Overlay.MODE_EDIT = 1;

  Overlay.prototype.errorTimer = 0;

  Overlay.prototype.showError = false;

  Overlay.prototype.tempObject = null;

  return Overlay;
}.call(undefined);

},{"../objects/particle.js":7,"./renderer/easeljs/easeljs-renderer.js":13,"./widget.js":18}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _particleRenderer = require("./particle-renderer.js");

var _particleRenderer2 = _interopRequireDefault(_particleRenderer);

var _simulationRenderer = require("../simulation-renderer.js");

var _simulationRenderer2 = _interopRequireDefault(_simulationRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var EaselJSRenderer;

exports.default = EaselJSRenderer = function (_SimulationRenderer) {
  _inherits(EaselJSRenderer, _SimulationRenderer);

  function EaselJSRenderer(stage, interpolator, settings) {
    _classCallCheck(this, EaselJSRenderer);

    var _this = _possibleConstructorReturn(this, (EaselJSRenderer.__proto__ || Object.getPrototypeOf(EaselJSRenderer)).call(this, interpolator));

    _this.stage = stage;
    _this.settings = settings;
    _this.renderObjs = [];
    _this.interpolator.addListener("before-update", function () {
      var j, len, particle, ref, results;
      ref = _this.renderObjs;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        results.push(particle.capture());
      }
      return results;
    });
    return _this;
  }

  _createClass(EaselJSRenderer, [{
    key: "addParticle",
    value: function addParticle(particle) {
      var pr;
      pr = new _particleRenderer2.default(particle, this.settings.simulation.enableSelection);
      particle.renderer = pr;
      this.stage.addChild(pr.displayObj);
      this.renderObjs.push(pr);
      return pr;
    }
  }, {
    key: "getParticlesAtPos",
    value: function getParticlesAtPos(x, y) {
      var j, len, list, ref, renderable;
      list = [];
      ref = this.renderObjs;
      for (j = 0, len = ref.length; j < len; j++) {
        renderable = ref[j];
        if (this.isParticleAtPos(renderable, x, y)) {
          list.push(renderable);
        }
      }
      return list;
    }
  }, {
    key: "isParticleAtPos",
    value: function isParticleAtPos(particle, x, y) {
      var dx, dy, p;
      p = particle.particle;
      dx = p.x - x;
      dy = p.y - y;
      if (dx * dx + dy * dy <= p.radius * p.radius) {
        return true;
      }
      return false;
    }
  }, {
    key: "removeParticles",
    value: function removeParticles(particles) {}

    //todo

  }, {
    key: "removeParticle",
    value: function removeParticle(particle) {
      var i, j, len, p, ref, results;
      ref = this.renderObjs;
      //console.log("removing particle")
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        p = ref[i];
        if (particle === p.particle) {
          particle.renderer = null;
          this.stage.removeChild(p.displayObj);
          this.renderObjs.splice(i, 1);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  }, {
    key: "getParticles",
    value: function getParticles() {
      return this.renderObjs;
    }
  }, {
    key: "clear",
    value: function clear() {
      var j, len, p, ref;
      ref = this.renderObjs;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        this.stage.removeChild(p.displayObj);
        p.particle = null;
      }
      return this.renderObjs = [];
    }
  }, {
    key: "draw",
    value: function draw(interpolation) {
      var j, len, particle, ref;
      ref = this.renderObjs;
      for (j = 0, len = ref.length; j < len; j++) {
        particle = ref[j];
        particle.draw(interpolation);
      }
      return this.stage.update();
    }
  }]);

  return EaselJSRenderer;
}(_simulationRenderer2.default);

},{"../simulation-renderer.js":16,"./particle-renderer.js":14}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _renderer = require("../renderer.js");

var _renderer2 = _interopRequireDefault(_renderer);

var _point2d = require("../../../math/point-2d.js");

var _point2d2 = _interopRequireDefault(_point2d);

var _eventManager = require("../../../events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

var _interpolator = require("../../../interpolator.js");

var _interpolator2 = _interopRequireDefault(_interpolator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var ParticleRenderer;

exports.default = ParticleRenderer = function () {
  var ParticleRenderer = function (_Renderer) {
    _inherits(ParticleRenderer, _Renderer);

    function ParticleRenderer(particle, enableSelection) {
      _classCallCheck(this, ParticleRenderer);

      var _this = _possibleConstructorReturn(this, (ParticleRenderer.__proto__ || Object.getPrototypeOf(ParticleRenderer)).call(this));

      _this.particle = particle;
      _this.enableSelection = enableSelection;
      _this.displayObj = new createjs.Shape();
      _this.lastX = _this.particle.x;
      _this.lastY = _this.particle.y;
      _this.selected = false;
      _this.displayObj.x = _this.particle.x;
      _this.displayObj.y = _this.particle.y;
      _this.displayObj.on("click", function (ev) {
        if (!_this.enableSelection) {
          return;
        }
        if (_this.selected) {
          _this.fire("deselect", [ev, _this]);
          return _this.deselect();
        } else {
          _this.fire("select", [ev, _this]);
          return _this.select();
        }
      });
      _this.graphics = _this.displayObj.graphics;
      _this.update();
      _eventManager2.default.eventify(_this);
      return _this;
    }

    _createClass(ParticleRenderer, [{
      key: "capture",
      value: function capture() {
        this.lastX = this.particle.x;
        return this.lastY = this.particle.y;
      }
    }, {
      key: "select",
      value: function select() {
        this.selected = true;
        return this.update();
      }
    }, {
      key: "deselect",
      value: function deselect() {
        this.selected = false;
        this.update();
        return this.pastPositions = [];
      }
    }, {
      key: "update",
      value: function update() {
        var r;
        r = this.particle.radius;
        this.graphics.clear().beginFill(this.particle.style).drawCircle(0, 0, r).endFill();
        if (this.selected) {
          this.graphics.setStrokeStyle(4).beginStroke("red").drawCircle(0, 0, r).endStroke();
        }
        return this.displayObj.cache(-r - 4, -r - 4, r * 2 + 8, r * 2 + 8);
      }
    }, {
      key: "draw",
      value: function draw(interpolation) {
        var newX, newY;
        newX = this.particle.x;
        newY = this.particle.y;
        if (interpolation > 0.0) {
          newX = _interpolator2.default.interpolate(this.lastX, newX, interpolation);
          newY = _interpolator2.default.interpolate(this.lastY, newY, interpolation);
        }
        this.displayObj.x = newX;
        this.displayObj.y = newY;
        if (this.particle.needsUpdate) {
          this.particle.needsUpdate = false;
          return this.update();
        }
      }
    }]);

    return ParticleRenderer;
  }(_renderer2.default);

  ;

  ParticleRenderer.prototype.pastPositions = [];

  ParticleRenderer.prototype.curPos = 0;

  return ParticleRenderer;
}.call(undefined);

},{"../../../events/event-manager.js":3,"../../../interpolator.js":4,"../../../math/point-2d.js":5,"../renderer.js":15}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var Renderer;

exports.default = Renderer = function () {
  function Renderer() {
    _classCallCheck(this, Renderer);
  }

  _createClass(Renderer, [{
    key: "draw",
    value: function draw(interpolation) {}
  }]);

  return Renderer;
}();

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _renderer = require("./renderer.js");

var _renderer2 = _interopRequireDefault(_renderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var SimulationRenderer;

exports.default = SimulationRenderer = function (_Renderer) {
  _inherits(SimulationRenderer, _Renderer);

  function SimulationRenderer(interpolator) {
    _classCallCheck(this, SimulationRenderer);

    var _this = _possibleConstructorReturn(this, (SimulationRenderer.__proto__ || Object.getPrototypeOf(SimulationRenderer)).call(this));

    _this.interpolator = interpolator;
    return _this;
  }

  _createClass(SimulationRenderer, [{
    key: "addParticle",
    value: function addParticle(particle) {}
  }, {
    key: "removeParticle",
    value: function removeParticle(particle) {}
  }]);

  return SimulationRenderer;
}(_renderer2.default);

},{"./renderer.js":15}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widget = require("./widget.js");

var _widget2 = _interopRequireDefault(_widget);

var _particle = require("../objects/particle.js");

var _particle2 = _interopRequireDefault(_particle);

var _eventManager = require("../events/event-manager.js");

var _eventManager2 = _interopRequireDefault(_eventManager);

var _easeljsRenderer = require("./renderer/easeljs/easeljs-renderer.js");

var _easeljsRenderer2 = _interopRequireDefault(_easeljsRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.2.2
var Simulation;

exports.default = Simulation = function () {
  var Simulation = function (_Widget) {
    _inherits(Simulation, _Widget);

    function Simulation(canvasName, engine, interpolator, settings) {
      _classCallCheck(this, Simulation);

      var _this = _possibleConstructorReturn(this, (Simulation.__proto__ || Object.getPrototypeOf(Simulation)).call(this, canvasName));

      _this.engine = engine;
      _this.interpolator = interpolator;
      _this.settings = settings;
      _this.engine.width = _this.width;
      _this.engine.height = _this.height;
      _this.renderer = new _easeljsRenderer2.default(_this.stage, _this.interpolator, _this.settings);
      _eventManager2.default.eventify(_this);
      return _this;
    }

    _createClass(Simulation, [{
      key: "resize",
      value: function resize(newWidth, newHeight) {
        _get(Simulation.prototype.__proto__ || Object.getPrototypeOf(Simulation.prototype), "resize", this).call(this, newWidth, newHeight);
        return this.engine.setBounds(this.width, this.height);
      }
    }, {
      key: "addParticle",
      value: function addParticle(x, y, mass, radius, style) {
        var _this2 = this;

        var particle, result;
        particle = new _particle2.default(x, y, radius, style, this.settings);
        particle.mass = mass;
        result = this.renderer.addParticle(particle);
        result.addListener("select", function (ev, particle) {
          _this2.fire("particle-selected", [particle.particle]);
          if (_this2.selected !== null) {
            _this2.selected.renderer.deselect();
          }
          return _this2.selected = particle.particle;
        }).addListener("deselect", function (ev, particle) {
          _this2.selected = null;
          return _this2.fire("particle-deselected", [particle.particle]);
        });
        this.engine.particles.push(particle);
        return particle;
      }
    }, {
      key: "removeParticle",
      value: function removeParticle(index) {
        var i, j, len, p, ref, results;
        if ((typeof index === "undefined" ? "undefined" : _typeof(index)) === "object") {
          this.renderer.removeParticle(index);
          ref = this.engine.particles;
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            p = ref[i];
            if (p === index) {
              this.engine.particles.splice(i, 1);
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        } else {
          this.renderer.removeParticle(this.engine.particles[index]);
          return this.engine.particles.splice(index, 1);
        }
      }
    }, {
      key: "loadParticles",
      value: function loadParticles(toBeLoaded) {
        var j, len, obj, particle, results;
        this.restart();
        results = [];
        for (j = 0, len = toBeLoaded.length; j < len; j++) {
          obj = toBeLoaded[j];
          particle = this.addParticle(obj.x, obj.y, obj.mass, obj.radius, obj.style);
          particle.xVel = obj.xVel;
          particle.yVel = obj.yVel;
          results.push(particle.cOR = obj.cOR);
        }
        return results;
      }
    }, {
      key: "saveParticles",
      value: function saveParticles(saved) {
        var j, len, particle, ref, results;
        ref = this.engine.particles;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          particle = ref[j];
          results.push(saved.push(particle.copy()));
        }
        return results;
      }
    }, {
      key: "removeSelected",
      value: function removeSelected() {
        var i, j, len, particle, ref;
        if (this.selected !== null) {
          ref = this.particles;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            particle = ref[i];
            if (particle === this.selected) {
              this.removeParticle(i);
            }
          }
          return this.selected = null;
        }
      }
    }, {
      key: "getSelected",
      value: function getSelected() {
        return this.selected;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.renderer.clear();
        this.selected = null;
        this.engine.reset();
        return this.fire("restart");
      }
    }, {
      key: "draw",
      value: function draw(interpolation) {
        this.renderer.draw(interpolation);
        return this.fire("draw");
      }
    }]);

    return Simulation;
  }(_widget2.default);

  ;

  Simulation.prototype.selected = null;

  return Simulation;
}.call(undefined);

},{"../events/event-manager.js":3,"../objects/particle.js":7,"./renderer/easeljs/easeljs-renderer.js":13,"./widget.js":18}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.2.2
var Widget, rgb2hex;

rgb2hex = function rgb2hex(rgb) {
  var hex;
  if (rgb.search("rgb") === -1) {
    return rgb;
  } else {
    rgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
    hex = function hex(x) {
      return ("0" + parseInt(x).toString(16)).slice(-2);
    };
    return "#" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
  }
};

exports.default = Widget = function () {
  function Widget(canvasName) {
    _classCallCheck(this, Widget);

    this.canvasName = canvasName;
    this.canvas = $("#" + this.canvasName);
    this.hidden = false;
    this.width = this.canvas.width();
    this.height = this.canvas.height();
    this.canvas.attr("width", this.width);
    this.canvas.attr("height", this.height);
    this.stage = new createjs.StageGL(this.canvasName);
    this.stage.setClearColor(rgb2hex(this.canvas.css("background-color")));
  }

  _createClass(Widget, [{
    key: "init",
    value: function init() {}
  }, {
    key: "addEventListener",
    value: function addEventListener(event, handler) {
      return this.stage.addEventListener(event, handler);
    }
  }, {
    key: "draw",
    value: function draw(interpolation) {}
  }, {
    key: "restart",
    value: function restart() {}
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "resume",
    value: function resume() {
      return this.paused = false;
    }
  }, {
    key: "pause",
    value: function pause() {
      return this.paused = true;
    }
  }, {
    key: "resize",
    value: function resize(newWidth, newHeight) {
      if (typeof newWidth === "undefined") {
        this.width = this.canvas.width();
        this.height = this.canvas.height();
      } else {
        this.width = newWidth;
        this.height = newHeight;
      }
      this.canvas.attr("width", this.width);
      this.canvas.attr("height", this.height);
      return this.stage.updateViewport(this.width, this.height);
    }
  }, {
    key: "show",
    value: function show() {
      this.hidden = false;
      return this.canvas.fadeIn(200);
    }
  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      return this.canvas.fadeOut(200);
    }
  }]);

  return Widget;
}();

},{}]},{},[10])(10)
});